\section{Methodology and Algorithms}

\subsection{Overview}
The \textbf{Sirr} application implements a hybrid end-to-end encryption system that combines the asymmetric security of RSA with the efficiency of symmetric AES encryption. 
The program is written in Swift using Apple's \texttt{CryptoKit} and \texttt{Security} frameworks, ensuring secure key management via the macOS Keychain while maintaining high performance through native cryptographic APIs.

\subsection{Key Generation}
Each device automatically generates an RSA-4096 key pair on first launch:
\begin{itemize}
  \item The \textbf{private key} is created and stored securely within the macOS Keychain using \texttt{SecKeyCreateRandomKey}, protected by the system’s Secure Enclave and user login credentials.
  \item The \textbf{public key} is derived via \texttt{SecKeyCopyPublicKey} and may be exported for sharing with other users.
\end{itemize}

Let $(K_{pub}, K_{priv})$ denote the RSA public/private key pair.

\subsection{Hybrid Encryption Algorithm}
When encrypting a message $M$ for a recipient:
\begin{enumerate}
  \item A random 256-bit symmetric key $K_{AES}$ is generated.
  \item $M$ is encrypted with AES in Galois/Counter Mode (GCM):
  \[
  C, \text{tag} = \mathrm{AES\_GCM\_Encrypt}(K_{AES}, M, \text{nonce})
  \]
  where \texttt{nonce} is a 12-byte random value.
  \item $K_{AES}$ is then encrypted using the recipient’s public key:
  \[
  K_{enc} = \mathrm{RSA\_Encrypt_{OAEP}}(K_{pub}^{(R)}, K_{AES})
  \]
  \item A digital signature is created with the sender’s private key:
  \[
  \sigma = \mathrm{RSA\_Sign_{PSS}}(K_{priv}^{(S)}, \mathrm{SHA256}(C))
  \]
  \item The final encrypted envelope is packaged in JSON format:
  \[
  \{
    \text{"enc\_key"}: K_{enc},
    \text{"ciphertext"}: C,
    \text{"nonce"}: \text{nonce},
    \text{"signature"}: \sigma,
    \text{"alg"}: \text{``RSA-OAEP-256 + AES-GCM + RSA-PSS-256''}
  \}
  \]
\end{enumerate}

The AES key and ciphertext are Base64-encoded for portability.

\subsection{Decryption and Verification}
Upon receiving the envelope:
\begin{enumerate}
  \item The recipient decrypts $K_{enc}$ with their private key to recover $K_{AES}$:
  \[
  K_{AES} = \mathrm{RSA\_Decrypt_{OAEP}}(K_{priv}^{(R)}, K_{enc})
  \]
  \item The ciphertext $C$ is decrypted using AES-GCM:
  \[
  M = \mathrm{AES\_GCM\_Decrypt}(K_{AES}, C, \text{nonce})
  \]
  \item The sender’s signature $\sigma$ is verified with their public key:
  \[
  \mathrm{Verify}_{RSA\_PSS}(K_{pub}^{(S)}, \mathrm{SHA256}(C), \sigma)
  \]
  If valid, $M$ is accepted as authentic and untampered.
\end{enumerate}

\subsection{Fingerprinting}
Each public key is identified by a SHA-256 fingerprint:
\[
\text{Fingerprint} = \mathrm{SHA256}(\text{DER}(K_{pub}))
\]
This fingerprint is displayed to users for manual verification via trusted channels.

\subsection{Data Security Model}
Private keys are never exported or stored in plaintext.  
All operations involving $K_{priv}$ occur within the Keychain environment.  
AES keys are ephemeral and generated per message, providing forward secrecy at the message level.  

\subsection{Implementation Summary}
\begin{itemize}
  \item \textbf{RSA-4096 / OAEP-SHA256} for key encapsulation.
  \item \textbf{AES-GCM-256} for message confidentiality and integrity.
  \item \textbf{RSA-PSS-SHA256} for sender authentication.
  \item \textbf{Base64 JSON} envelope for cross-platform transmission.
  \item \textbf{Keychain storage} for persistent private key protection.
\end{itemize}

This combination offers strong confidentiality, authenticity, and integrity guarantees while maintaining simplicity for end users through automated key management and minimal interaction.